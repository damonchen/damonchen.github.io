<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Damon小站</title>
    <link>http://damon121212.com/post/</link>
    <description>Recent content in Posts on Damon小站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 07 Jul 2016 11:43:00 +0800</lastBuildDate>
    <atom:link href="http://damon121212.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>docker compose</title>
      <link>http://damon121212.com/blog/2016/07/docker-compose-start/</link>
      <pubDate>Thu, 07 Jul 2016 11:43:00 +0800</pubDate>
      
      <guid>http://damon121212.com/blog/2016/07/docker-compose-start/</guid>
      <description>

&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;启动时不同镜像之间的链接的处理是比较麻烦的，所以官方目前有一个&lt;code&gt;docker-compose&lt;/code&gt;用来做这些事情，官方给的例子是这样的。&lt;/p&gt;

&lt;h2 id=&#34;构建一个-web-应用&#34;&gt;构建一个&lt;code&gt;Web&lt;/code&gt;应用&lt;/h2&gt;

&lt;p&gt;官方使用&lt;code&gt;Python&lt;/code&gt;下的&lt;code&gt;Flask&lt;/code&gt;框架构建的应用，创建了一个&lt;code&gt;app.py&lt;/code&gt;的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from flask import Flask
from redis import redis

app = Flask(__name__)
redis = Redis(host=&#39;redis&#39;, port=6379)


@app.route(&#39;/&#39;)
def hello():
    redis.incr(&#39;hits&#39;)
    return &amp;quot;Hello World! I have been seen %s times&amp;quot; % redis.get(&#39;hits&#39;)

if __name__ == &#39;__main__&#39;:
    app.run(host=&#39;0.0.0.0&#39;, debug=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个&lt;code&gt;requirements.txt&lt;/code&gt;的文件（给&lt;code&gt;pip&lt;/code&gt;安装程序用）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;flask
redis
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建一个docker镜像&#34;&gt;创建一个Docker镜像&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;首先构建一个&lt;code&gt;Dockerfile&lt;/code&gt;文件&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM Python:2.7
ADD . /code
WORKDIR /code
RUN pip install -r requirements.txt
CMD python app.py
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;然后构建镜像&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build -t web .
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;定义服务&#34;&gt;定义服务&lt;/h2&gt;

&lt;p&gt;通过&lt;code&gt;docker-compose.yml&lt;/code&gt;定义服务：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;
version: &#39;2&#39;
services:
    web:
        build: .
        ports:
        - &amp;quot;5000:5000&amp;quot;
        volumes:
        - .:/code
        depends_on:
        - redis
    redis:
        image: redis
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于&lt;code&gt;depends_on&lt;/code&gt;和&lt;code&gt;links&lt;/code&gt;之间的差异见: &lt;a href=&#34;http://stackoverflow.com/questions/35832095/difference-between-links-and-depends-on-in-docker-compose-yml&#34; target=&#34;_blank&#34;&gt;http://stackoverflow.com/questions/35832095/difference-between-links-and-depends-on-in-docker-compose-yml&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;运行&#34;&gt;运行&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-compose up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;compose&lt;/code&gt;会拉取&lt;code&gt;redis&lt;/code&gt;的镜像，构建代码，然后启动服务，在浏览器中输入&lt;code&gt;http://0.0.0.0:5000&lt;/code&gt;，就可以看到应用已经在运行了。&lt;/p&gt;

&lt;h2 id=&#34;一些实验&#34;&gt;一些实验&lt;/h2&gt;

&lt;p&gt;想要后台运行&lt;code&gt;compose&lt;/code&gt;，给个&lt;code&gt;-d&lt;/code&gt;(detach)参数，用&lt;code&gt;docker-compose ps&lt;/code&gt;查看运行的容器。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker-compose run&lt;/code&gt;命令允许在一个容器中运行指令，如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    docker-compose run web env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取&lt;code&gt;web&lt;/code&gt;服务的&lt;code&gt;env&lt;/code&gt;信息。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker-compose stop&lt;/code&gt;可以停止&lt;code&gt;-d&lt;/code&gt;启动的服务。&lt;/p&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;我在&lt;code&gt;ubuntu-14.04&lt;/code&gt;上跑&lt;code&gt;docker&lt;/code&gt;的时候，出现了
&lt;code&gt;ERROR: Couldn&#39;t connect to Docker daemon at http+docker://localunixsocket - is it running?&lt;/code&gt; 错误
需要修改&lt;code&gt;/etc/default/docker&lt;/code&gt;中的&lt;code&gt;DOCKER_OPTS&lt;/code&gt;，添加 &lt;code&gt;&amp;quot;-H tcp://127.0.0.1:4243 -H unix:///var/run/docker.sock&amp;quot;&lt;/code&gt;，重启&lt;code&gt;docker&lt;/code&gt;，设置环境变量&lt;code&gt;DOCKER_HOST&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export DOCKER_HOST=tcp://localhost:4243
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再执行&lt;code&gt;docker-compose up&lt;/code&gt;即可。 也可以试试 &lt;a href=&#34;https://github.com/docker/compose/issues/1214&#34; target=&#34;_blank&#34;&gt;https://github.com/docker/compose/issues/1214&lt;/a&gt; 中说的方法：&lt;/p&gt;

&lt;p&gt;我使用的环境如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ uname -a
Linux ubuntu-14 4.2.0-27-generic #32~14.04.1-Ubuntu SMP Fri Jan 22 15:32:26 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux

$ docker version
Client:
 Version:      1.11.2
 API version:  1.23
 Go version:   go1.5.4
 Git commit:   b9f10c9
 Built:        Wed Jun  1 21:47:50 2016
 OS/Arch:      linux/amd64

$ docker-compose --version
docker-compose version 1.6.2, build 4d72027

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Go中使用uint64遇到的问题</title>
      <link>http://damon121212.com/blog/2016/07/golang-with-uint64-problems/</link>
      <pubDate>Wed, 06 Jul 2016 08:50:06 +0800</pubDate>
      
      <guid>http://damon121212.com/blog/2016/07/golang-with-uint64-problems/</guid>
      <description>&lt;p&gt;因为设计的缘故，我们内部系统使用了不少了&lt;code&gt;uint64&lt;/code&gt;，同时也带来了很多问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;Go&lt;/code&gt;的&lt;code&gt;mysql&lt;/code&gt;实现中，对于&lt;code&gt;uint64&lt;/code&gt;的转换，是分两部分的，具体代码（&lt;a href=&#34;https://github.com/go-sql-driver/mysql/blob/master/packets.go#1137）：&#34; target=&#34;_blank&#34;&gt;https://github.com/go-sql-driver/mysql/blob/master/packets.go#1137）：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;            case fieldTypeLongLong:
            if rows.columns[i].flags&amp;amp;flagUnsigned != 0 {
                val := binary.LittleEndian.Uint64(data[pos : pos+8])
                if val &amp;gt; math.MaxInt64 {
                    dest[i] = uint64ToString(val)
                } else {
                    dest[i] = int64(val)
                }
            } else {
                dest[i] = int64(binary.LittleEndian.Uint64(data[pos : pos+8]))
            }
            pos += 8
            continue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面可以看到，对于&lt;code&gt;uint64&lt;/code&gt;部分，是通过两个不同的数据类型来处理的。当将从数据库获取获取的所有数据以&lt;code&gt;map[string]interface{}&lt;/code&gt;形式返回时，map的value值类型就有可能是&lt;code&gt;int64&lt;/code&gt;和&lt;code&gt;uint64&lt;/code&gt;，这对于强类型的&lt;code&gt;Go&lt;/code&gt;而言，无疑是一个麻烦的事情，得自己做断言判断，常常会因为不小心遗漏而导致异常（不易发现）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在将&lt;code&gt;Go&lt;/code&gt;中的&lt;code&gt;uint64&lt;/code&gt;返回给前端的时候，由于&lt;code&gt;JavaScript&lt;/code&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/UInt64&#34; target=&#34;_blank&#34;&gt;不支持64位的整型数值&lt;/a&gt;，前端有可能会准确（值比较小，可以用32位的int表示），也有可能失败，这也是一个麻烦的事情。所以为了统一解决，需要将&lt;code&gt;uint64&lt;/code&gt;的数据，转换为字符串方式，然后转递给前端处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;后台传递给前端需要将&lt;code&gt;uint64&lt;/code&gt;转换为字符串，就需要在返回前去小心处理&lt;code&gt;uint64&lt;/code&gt;的值（这通常也是一个麻烦的事情）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>golang routine id</title>
      <link>http://damon121212.com/blog/2016/07/golang-routine-id/</link>
      <pubDate>Tue, 05 Jul 2016 17:33:22 +0800</pubDate>
      
      <guid>http://damon121212.com/blog/2016/07/golang-routine-id/</guid>
      <description>&lt;p&gt;在&lt;code&gt;Go&lt;/code&gt;中，系统是不提供&lt;code&gt;goroutine&lt;/code&gt;的&lt;code&gt;id&lt;/code&gt;给外界的，丫的认为这事情不应该提供给用户来使用。&lt;/p&gt;

&lt;p&gt;可有时候，实在是觉得这个东西必须得有呀，比方说后台开了个&lt;code&gt;goroutine&lt;/code&gt;进行&lt;code&gt;http&lt;/code&gt;请求的处理，这个免不了要打个日志什么的，
当并发量稍微大点的时候，就会发现这些信息的输出就交叉错乱在一起了。怎么区分。&lt;/p&gt;

&lt;p&gt;一种方案是在&lt;code&gt;http&lt;/code&gt;请求的时候，生成一个&lt;code&gt;context&lt;/code&gt;的东西，里面有个值来表示是这个&lt;code&gt;goroutine&lt;/code&gt;，然后打日志的时候将这个值输出来。
这种方案的问题是：你得将这个&lt;code&gt;context&lt;/code&gt;显示的一路传递下去，显然这个这很多时候会很痛苦。&lt;/p&gt;

&lt;p&gt;另一种方案是如果系统能够提供一个标识来表明这个&lt;code&gt;goroutine&lt;/code&gt;的信息，那么就不必要这么麻烦了。所以考虑之后，决定采用这种获取系统的&lt;code&gt;goroutine id&lt;/code&gt;的方案。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go1.6&lt;/code&gt;中具体方法是在&lt;code&gt;src/runtime/proc.go&lt;/code&gt;尾部添加&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
// export Goid
func Goid() int64 {
    _g_ := getg()
    return _g_.goid
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新编译生成对应的&lt;code&gt;go&lt;/code&gt;编译器（最好用&lt;code&gt;go1.4&lt;/code&gt;来编译，省事），然后就可以在代码中用&lt;code&gt;runtime.Goid&lt;/code&gt;获取到对应的&lt;code&gt;id&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;线上跑了几个月，没有出现过异常，所以还是比较稳定的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>golang的一个丑陋实现</title>
      <link>http://damon121212.com/blog/2016/07/ugly-go-polymorphic/</link>
      <pubDate>Mon, 04 Jul 2016 22:11:39 +0800</pubDate>
      
      <guid>http://damon121212.com/blog/2016/07/ugly-go-polymorphic/</guid>
      <description>&lt;p&gt;好多些天前，我在&lt;code&gt;Golang实践群&lt;/code&gt;里问了下面代码的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Aer interface{
    Name()string
    PrintName()
}

type A struct {
}

func (a *A) Name() string {
    return &amp;quot;a&amp;quot;
}

func (a *A) PrintName() {
    fmt.Println(a.Name())
}

type B struct {
    A
}

func (b *B) Name() string {
    return &amp;quot;b&amp;quot;
}

func getAer() Aer {
    return &amp;amp;B{}
}

func main() {
    a := getAer()
    a.printName()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现中，&lt;code&gt;Go&lt;/code&gt;中输出出的是a，这个实现违反了通常&lt;code&gt;C++&lt;/code&gt;，&lt;code&gt;Java&lt;/code&gt;，&lt;code&gt;Python&lt;/code&gt;中会输出b的实现，由于上述几个语言的思维习惯已经形成，那么这个实现就会导致很多意想不到的事情。&lt;/p&gt;

&lt;p&gt;昨儿个在&lt;code&gt;Golang实践群&lt;/code&gt;中，有赞的兄弟（这位兄弟知道我提的上面的问题，并说这个是&lt;code&gt;Go&lt;/code&gt;的实现方式）就问到了，在&lt;code&gt;UnmarshalJSON&lt;/code&gt;的时候，为何Test字段没有被赋值，并在&lt;code&gt;Go&lt;/code&gt;中提了&lt;a href=&#34;https://github.com/golang/go/issues/15890&#34; target=&#34;_blank&#34;&gt;issue&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;他的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
    &amp;quot;encoding/json&amp;quot;
    &amp;quot;fmt&amp;quot;
)

type request struct {
    Operations map[string]op `json:&amp;quot;operations&amp;quot;`
}
type op struct {
  operation
  Test string  `json:&amp;quot;test&amp;quot;`
}
type operation struct {
    Width  int    `json:&amp;quot;width&amp;quot;`
    Height int    `json:&amp;quot;height&amp;quot;`
}

func (o *operation) UnmarshalJSON(b []byte) error {
    type xoperation operation
    xo := &amp;amp;xoperation{Width: 500, Height: 500}
    if err := json.Unmarshal(b, xo); err != nil {
        return err
    }
    *o = operation(*xo)
    return nil
}

func main() {
    jsonStr := `{
            &amp;quot;operations&amp;quot;: {
                &amp;quot;001&amp;quot;: {
                    &amp;quot;test&amp;quot;:&amp;quot;test&amp;quot;,
                    &amp;quot;width&amp;quot;: 100
                }
            }
        }`
    req := request{}
    json.Unmarshal([]byte(jsonStr), &amp;amp;req)
    fmt.Println(req)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个问题的本质和我提出的那个问题一样，因为op中嵌入了operation，所以有了&lt;code&gt;UnmarshalJSON&lt;/code&gt;,符合了json包中&lt;code&gt;Unmarshaler&lt;/code&gt;接口，所以内部用接口去处理的时候，op是满足的，但实际处理的是operation，也就是以operation作为实体来进行&lt;code&gt;UnmarshalJSON&lt;/code&gt;，导致了诡异的错误信息。&lt;/p&gt;

&lt;p&gt;我以为，这是&lt;code&gt;Go&lt;/code&gt;实现中非常丑陋的一个地方。&lt;/p&gt;

&lt;p&gt;按照耗子哥说的，如果语言实现规则是知道的，还是容易犯错误的，那就是一个坑。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>golang中几种加密方式的处理</title>
      <link>http://damon121212.com/blog/2016/07/golang-encrypt-sample/</link>
      <pubDate>Mon, 04 Jul 2016 22:05:31 +0800</pubDate>
      
      <guid>http://damon121212.com/blog/2016/07/golang-encrypt-sample/</guid>
      <description>

&lt;h2 id=&#34;缘由&#34;&gt;缘由&lt;/h2&gt;

&lt;p&gt;在与第三方平台进行接入的时候，通常会存在一些签名或者加密的处理，在进行开发的时候，因为语言的
不同，需要按照规范进行相应处理。&lt;/p&gt;

&lt;h2 id=&#34;des加解密&#34;&gt;DES加解密&lt;/h2&gt;

&lt;p&gt;DES：&lt;a href=&#34;https://en.wikipedia.org/wiki/Data_Encryption_Standard&#34; target=&#34;_blank&#34;&gt;https://en.wikipedia.org/wiki/Data_Encryption_Standard&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;golang中的标准库crypto/des中有DES的实现，但是golang库的描述比较简单，如果不熟悉DES的加密规则，是不容易
进行相应代码编写的，与第三方进行不同语言之间的加密与解密时，也容易混淆，出现错误。&lt;/p&gt;

&lt;p&gt;DES区分为CBC和EBC加密模式，并且有不同的填充方式。&lt;/p&gt;

&lt;p&gt;CBC（等）：&lt;a href=&#34;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation&#34; target=&#34;_blank&#34;&gt;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation&lt;/a&gt;
Padding：&lt;a href=&#34;https://en.wikipedia.org/wiki/Padding_(cryptography&#34; target=&#34;_blank&#34;&gt;https://en.wikipedia.org/wiki/Padding_(cryptography&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;注意 &lt;strong&gt;PKCS#5 padding is identical to PKCS#7 padding&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以对不同的平台与语言进行DES加解密对接时，需要知道对方的是采用何种加密模式以及何种填充方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Windows 默认是CBC模式，CryptSetKeyParam函数，openssl 函数名中直接表明&lt;/li&gt;
&lt;li&gt;Java 中如果Cipher.getInstance()中不填写，默认是DES/ECB/PKCS5Padding&lt;/li&gt;
&lt;li&gt;C# 中默认是CBC模式，PKCS7Padding(PKCS5Padding)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;golang默认提供的是CBC模式，所以对于ECB模式，需要自己编写代码&lt;/p&gt;

&lt;p&gt;PKCS5Padding与PKCS5Unpadding&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;    func PKCS5Padding(ciphertext []byte, blockSize int) []byte {
        padding := blockSize - len(ciphertext)%blockSize
        padtext := bytes.Repeat([]byte{byte(padding)}, padding)
        return append(ciphertext, padtext...)
    }

    func PKCS5Unpadding(origData []byte) []byte {
        length := len(origData)
        unpadding := int(origData[length-1])
        return origData[:(length - unpadding)]
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ECB加密模式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
        block, err := des.NewCipher(key)
        if err != nil {
            ...
        }
        bs := block.BlockSize()
        src = PKCS5Padding(src, bs)
        if len(src)%bs != 0 {
            ....
        }
        out := make([]byte, len(src))
        dst := out
        for len(src) &amp;gt; 0 {
            block.Encrypt(dst, src[:bs])
            src = src[bs:]
            dst = dst[bs:]
        }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ECB下的解密&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
    block, err := des.NewCipher(key)
    if err != nil {
        ...
    }

    out := make([]byte, len(src))
    dst := out
    bs := block.BlockSize()
    if len(src)%bs != 0 {
        ...
    }

    for len(src) &amp;gt; 0 {
        block.Decrypt(dst, src[:bs])
        src = src[bs:]
        dst = dst[bs:]
    }
    out = PKCS5UnPadding(out)

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rsa加解密&#34;&gt;RSA加解密&lt;/h2&gt;

&lt;p&gt;与其他语言默认有更高级的封装不同，golang中需要依据不同的概念，自己组合进行封装处理，为此，需要先理解几个不同的概念。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Privacy-enhanced_Electronic_Mail&#34; target=&#34;_blank&#34;&gt;PEM&lt;/a&gt;，通常是以.pem结尾的文件，在密钥存储和X.509证书体系中使用比较多，下面是一个X509证书下的PEM格式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-----BEGIN CERTIFICATE-----
    base64
-----END CERTIFICATE-----
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/PKCS&#34; target=&#34;_blank&#34;&gt;PKCS&lt;/a&gt; 这是一个庞大的体系，不同的密钥采用不同的pkcs文件格式。如私钥采用pkcs8。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/X.509&#34; target=&#34;_blank&#34;&gt;X.509&lt;/a&gt; 这是一个公钥管理基础（public key infrastructure, pki)，在IETF中通常对应PKIX。&lt;/p&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;使用 openssl（如&lt;code&gt;openssl genrsa -out rsa_private_key.pem 1024&lt;/code&gt;)生成的pem文件，就是符合PEM格式的，以&lt;code&gt;-----BEGIN RSA PRIVATE KEY-----&lt;/code&gt;开头，&lt;code&gt;-----END RSA PRIVATE KEY-----&lt;/code&gt;结尾。&lt;/p&gt;

&lt;p&gt;也可以转换为pkcs8:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，虽然数据格式pkcs8格式，但是-outform也表明了，文件格式仍旧是符合PEM格式的，只是两个PEM文件是存在差异的。&lt;/p&gt;

&lt;p&gt;清楚了上面几种概念与格式之后，编写golang对应的公钥与私钥加解密方式，就相对容易一些，首先是将pem文件解码，然后进行对应的密码解码为golang支持的结构体，再进行相应的处理。&lt;/p&gt;

&lt;p&gt;如对于私钥，可以进行如下操作进行签名：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;    block, _ := pem.Decode([]byte(key))
    if block == nil {       // 失败情况
        ....
    }

    private, err := x509.ParsePKCS8PrivateKey(block.Bytes)
    if err != nil {
        ...
    }

    h := crypto.Hash.New(crypto.SHA1)
    h.Write(data)
    hashed := h.Sum(nil)

    // 进行rsa加密签名
    signedData, err := rsa.SignPKCS1v15(rand.Reader, private.(*rsa.PrivateKey), crypto.SHA1, hashed)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过私钥进行解密，代码格式如下；&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
    block, _ := pem.Decode([]byte(key))
    if block == nil {       // 失败情况
        ....
    }

    private, err := x509.ParsePKCS8PrivateKey(block.Bytes)
    if err != nil {
        ...
    }

    v, err := rsa.DecryptPKCS1v15(rand.Reader, private, data)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于公钥对数据进行加密：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
    block, _ := pem.Decode([]byte(key))
    if block == nil {       // 失败情况
        ....
    }

    pub, err := x509.ParsePKIXPublicKey(block.Bytes)
    if err != nil {
        ...
    }

    encryptedData, err := rsa.EncryptPKCS1v15(rand.Reader, pub.(*rsa.PublicKey), data)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;

&lt;p&gt;搞清楚具体的加密方式，然后再在&lt;code&gt;Go&lt;/code&gt;里面编写，代码还是很清晰也不难看懂。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>linux标准daemon编写方式</title>
      <link>http://damon121212.com/blog/2016/07/daemon-process/</link>
      <pubDate>Mon, 04 Jul 2016 22:00:09 +0800</pubDate>
      
      <guid>http://damon121212.com/blog/2016/07/daemon-process/</guid>
      <description>

&lt;h2 id=&#34;daemon定义&#34;&gt;daemon定义&lt;/h2&gt;

&lt;p&gt;运行在后台的程序，通常不需要与用户进行交互的。&lt;/p&gt;

&lt;p&gt;任何父进程id是0的通常是kernel进程，作为系统启动的一部分，除了init是用户态的命令。&lt;/p&gt;

&lt;h2 id=&#34;规则&#34;&gt;规则&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一件事情是调用umask设置文件模型的mask为0，文件mode creation mask可以被进程继承，但daemon进程需要创建文件时，需要特殊的权限。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用fork，退出父进程exit，这可以做几件事情，首先，daemon将使用shell命令行启动，其次，子进程继承了process group id，但获取一个新的id，因此我们可以确保子进程不会是一个process group leader，为调用setsid做准备。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用setsid创建一个新的session。该进程开始成为一个新的session的session leader，然后成为新的process group的process group leader，并且没有controlling terminal。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;一些基于System V的用户推荐再fork一下，第二个child仍旧是一个daemon，然后保证该daemon不是一个session leader，在System V规则下阻止得到一个控制终端。&lt;/p&gt;

&lt;p&gt;避免获取一个终端，使用O_NOCTTY来确保打开一个非终端设备。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;修改当前目录为根目录（即/），为房子daemon存在于mounted file system中，系统重启时，文件系统不能够unmounted。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不需要的文件描述符应该关闭，阻止从parent中继承下来的文件描述符。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于没有终端的缘故，因此需要将文件描述符0，1和2将切换到/dev/null。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>start</title>
      <link>http://damon121212.com/blog/2016/07/start/</link>
      <pubDate>Mon, 04 Jul 2016 16:10:09 +0800</pubDate>
      
      <guid>http://damon121212.com/blog/2016/07/start/</guid>
      <description>&lt;p&gt;星辰大海，扬帆了。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>